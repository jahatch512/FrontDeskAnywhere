when it came to generating the hex color, some initial obstacles were apparent right away:
1. Ensure that the most minor change in price will create a visible change in color
 -- First, I completely reversed the initial rate for any even rates. That way, a rate of 123.45 would produce a VERY different result than a rate of 123.46 and I had a baseline of randomness.
 -- I then cubed each individual number before converting it to hex. This way, I further separated numbers that would normally be close, i.e a rate change from 2 to 3 became 8 to 27 in the hex generator.
2. Ensure that each rate produces a 6-digit hex code
 -- Smallest possible hex number (rate: 000.00) is only 5 numbers so add #0 to start of all final answers. To make this function more random and varied, I would also systematically randomize the first digit.
 -- My current method does an ok job of randomization/variation. However, it has not been thoroughly tested and there are certainly edge cases that most likely do not fit the criteria of the function.
    In order to improve the randomness I could add in more layers of manipulation (reverse the array once for every odd digit in the rate) but I would need to consider any increase in time complexity that this might add.

As for the calendar parsing, there were again some clear spots that presented a challenge:
1. As with many functions that involve iterating through an array of information, there was some weird behavior on the ends of the array.
 -- Without being able to know when a new rate “period” would start/end, the function must keep track of data from previous objects in the array (previousDate). In this way, each time a new rate was established, I had to complete the information for the old rate period and begin the information for the new rate period.
 -- After writing the code to deal with the last object in the input array, I realized I could re-factor. If the last date has a different rate, then the function will create a new rate period with all of the info except period-end. If the last date does not have a different rate, then the current rate period object would only need the period-end as well. Because of this, the only thing the function does differently for the final date/rate input object is to add the final period-end date to the rate period output object.
2. An important consideration of mine is always code efficiency, most directly measured by time and space complexity. I did analyze this code and tried to find areas to improve efficiency.
 -- I did some reading on the JS Array methods slice() and splice(). It seems that slice() is always O(n) while splice() can sometimes be more efficient depending on the memory allocation and caching techniques of the runtime engine being used. One improvement I would make in my code would be to change all slice() methods to splice() methods to take advantage of the potential increased efficiency.
 -- It appears that the time complexity of the rateParser() function is O(n^2) because the slice() method is nested within the outer array loop. My instinct is that because the slice value is constant (-2), there is a way I could eliminate the method altogether and get this application down to an O(n) runtime.
